% !TEX root = ../thesis.tex

\chapter{Design of the Learning Environment}
\label{chap:design}

In this section all implementation tools and approaches are explained.
First our used framework will be explained, then how our different scenes and objects are generated and
at last how these two are combined to our final solution.

\section{Phaser 3}
%https://labs.phaser.io/
%https://phaser.io/
%https://photonstorm.github.io/phaser3-docs/

\subsection{Scenes}
\subsection{Managers}
\section{Object generation}
Our objects can have up to four properties with at maximum one from each of the following categories:
\begin{itemize}
    \item Geometrical shape (square, triangle, circle, ellipse, rhombus, octagon)
    \item Color (yellow, orange, red, purple, green, blue)
    \item Holes or dots (one, two, three, four, five, six)
    \item Filling (filled, striped, dotted)
\end{itemize}

We need all possible objects with one, three and four properties.

With a python script [EXAMPLE] scalable vector graphic (SVG) files are generated [EXAMPLE].
After that they are converted to portable network graphic (PNG) files with the GNU image manipulation program (GIMP),
so that they can be imported into Phaser.

\section{Objects}
\subsection{Object Storage}
Our objects are images with different properties.
These properties cannot be saved in the images itself.
for that reason the image path with the respective properties are stored in a easily accessible
"JavaScript Object Notation" (JSON) file.

\begin{lstlisting}[style=TypeScript, caption={geometrical\_objects.json}]
{
  "categories": [
    {
      "name": "cat1",
      "url": "color.png",
      "validElements": [
        {
          "name": "purple",
          "urls": [
            "purple1.png",
            "purple2.png",
            "purple3.png",
            "purple4.png",
            "purple5.png",
            "purple6.png"
          ]
        },
        ...
      ]
    },
    ...
  ],
  "images": [
    {
      "name": "purplesquareonefull.png",
      "cat1": "purple",
      "cat2": "square",
      "cat3": "one",
      "cat4": "full"
    },
    ...
  ]
}
\end{lstlisting}

For the correct way to access the fields please go to [INSERTCHAPTER].

\subsection{Object display}
Displaying just the image of an object without tweaking it a little can seem boring for the user.
So to add more diversity, every time an object is displayed in the game,
the object gets a random rotation angle, size and position.
Of course within certain predefined boundaries.

\subsection{Object Interaction}
Whenever possible, when the user interacts with an object, a generalization of the input code is used.
Instead of giving each object an event task, the global event task is fetched and the object via the event parameters.
This way the input interaction code is kept in one place.

\begin{lstlisting}[style=TypeScript, caption={Input code}]
    ...
    this.input.on('dragstart', function(pointer, gameObject) {
        ...
    }, this);

    this.input.on('drag', function(pointer, gameObject, dragX, dragY) {
        ...
    }, this);

    this.input.on('dragend', function(pointer, gameObject, dropped) {
        ...
        if (!dropped ...) {
            ...
        }
    }, this);

    this.input.on('drop', function(pointer, gameObject, dropZone) {
        ...
    }, this);
    ...
\end{lstlisting}

\section{Score Storage}
The achieved score is saved in the


\section{Introduction Animation Generation}
To produce animated instruction for the task later on,
the screen is recorded with OBS Studio while someone (here me) is playing the game.
Parts of the final video are then taken for the respective scenes and converted into single pictures.
These single pictures are saved in one picture (called spreadsheet [EXAMPLE]).
The phaser framework animates those spreadsheets.

Is is important to note, that different devices have a different limit for the resolution of images.
Tablets seem to have the lowest, namely 4096x4096 pixels.
The spreadsheet images are scaled down for that reason.

\section{Concept of the Learning Environment}
Through the boundary conditions and requirements of the learning environment,
we split our environment into multiple parts or here called scenes.

\subsection{Drop Down Menu}
Throughout the whole experience, the user can open a menu with a button.
This button is always visible.
Once the menu is open, the user may close the menu and return to the current scene,
exit the current scene and return to the level menu and go into fullscreen and back.
The current scene is paused while the menu is open as it can be distracting for the user,
if suddenly something pops up and covers parts of the visible and running scene.

\subsection{Welcome Screen}
The welcome screen is the starting point of the user experience.
Through this screen the user will be greeted by showing the name of the game.
Through a click he shall commence to the level menu.

\subsection{Level Menu}
In the level menu, the user is able to choose between different levels and games.
He can also access the object summary and track his progress/score.
The progress of each individual level is shown on the respective buttons.
The progress can be resetted by the reset button.

\subsection{Object Summary}
The Object summary allows the user to get a feeling for all the different properties an object can have.
For that reason the number of objects per category is restricted to five, as there are over 1000 different objects.
Objects are draggable and sortable by each category with a click on a respective button.

\subsection{Sorting with one Category}
Here the user has to sort the static objects with one category by the given category.
As the user should be able to experience all categories, they are split into different levels.
Each level represents a category.
For motivation, the user can track his progress.
The Progress is defined by objects sorted the right and the wrong way.

The amount of objects to sort, as well as the amount of properties of the category
is randomly selected each time you start the game.

\subsection{Sorting with one category under difficult conditions}
Here the user has to sort falling objects with one category by the given category.
As the user should be able to experience all categories, they are split into different level.
Each level represents a category.
For motivation, the user can track his progress.
The progress is defined by objects missed, sorted the right and the wrong way.
To make the task harder, dummy objects are added.
Those objects look similar to the original ones but with a succinct characteristic.
There are no negative points for missing such an object but negative points for sorting them in any way.

For more diversity, the amount of falling objects to sort, as well as the amount of properties of the category
is randomly selected each time you start the game.

\subsection{Sorting with restricted space}
In this scene the user has to sort a given number of objects with all properties shown into boxes with limited space.
The objects in one box must have at least one property in common and
can be put into the box and taken out an infinite amount of times.

To make the game more difficult, this level is split into two.
The first level has boxes with the size 6, 4, 2 and the second one boxes with the size 6, 5, 4.

\subsection{Object pairing - easy version}
In this game, twelve objects with three categories are shown.
the user has to select three objects which have to fulfil the following.
For each category (color, shape and number of holes/dots) one of the following conditions has to hold:
\begin{itemize}
    \item They must be the same (blue, blue, blue)
    \item They must be completely different (square, triangle, circle)
\end{itemize}
[EXAMPLE]

If the user needs help, there is a helper bar which can be accessed by a button with a question mark on it.
The helper bar shows which categories fulfil the conditions and which do not
by coloring the category symbols on the bar in green or red.

The game is time limited. The remaining time is shown by a bar.
If you select three onjects which fulfil the conditions, more time will be added.
After a set amount of correct selected objects, the game will end.

If there are no three objects that fulfil the conditions, the playfield will be generated anew.

\subsection{Object pairing - normal version}
In this game, twelve objects with four categories are shown.
the user has to select three objects which have to fulfil the following.
For each category (color, filling, shape and number of holes/dots) one of the following conditions has to hold:
\begin{itemize}
    \item They must be the same (blue, blue, blue)
    \item They must be completely different (square, triangle, circle)
\end{itemize}

[EXAMPLE]

If the user needs help, there is a helper bar which can be accessed by a button with a question mark on it.
The helper bar shows which categories fulfil the conditions and which do not
by coloring the category symbols on the bar in green or red.

The game is time limited. The remaining time is shown by a bar.
If you select three onjects which fulfil the conditions, more time will be added.
After a set amount of correct selected objects, the game will end.

If there are no three objects that fulfil the conditions, the playfield will be generated anew.

\subsection{Score Screen}
After a task has been completed, there is going to be a score.
This score is represented here with a displayed number of stars.
The minimum of starts is zero and the maximum is three.
If the user is unhappy with his results, he can replay the game by clicking on the replay button.

\subsection{Introduction}
Before each game starts, a sample animation of the task beforehand is being shown.
The current scene is paused in the meantime, so that the user has enough time to find out what he has to do.

\section{Code structure of the learning environment}
Our learning environment consists of different scenes each one inheriting the base scene.
The following subsections won't contain the whole code as some parts are trivial to understand.
Instead a summary of the scenes purpose and crucial parts are shown and explained.

The full code can be accessed here [INSERT LINK].

[IMAGE\_OF\_STATE\_DIAGRAM]

\subsection{BaseScene}
This scene contains methods and fields which are neccessary in multiple scenes
(e.g. the scene transition, indentifier of the scene, ...).

The transition is a mask in the form of a circle layed over a black rectangle.
Masks have to be applied to every object they have to mask.
So a simple solution was to lay a black rectangle over the whole scene and mask it.
The animated transition is created by increasing or decreasing the radius of the circle
mask according to the wanted animation (IN/OUT).

\begin{lstlisting}[style=TypeScript, caption={BaseScene.ts}]
    /**
     * Method for initializing the shape, position and properties of the graphical scene transition
     */
    private transitionInit(): void {
        // Shape of the graphical transition
        const circle: Phaser.GameObjects.Graphics = this.add.graphics();

        // Shape of the screen
        const rectangle: Phaser.GameObjects.Rectangle = this.add.rectangle(0, 0, this.cameras.main.width, this.cameras.main.height, 0x000000);

        // Define circle as the mask
        const mask: Phaser.Display.Masks.GeometryMask = circle.createGeometryMask();

        circle.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);
        circle.fillCircle(0, 0, 0.1);
        circle.setDepth(0);

        mask.setInvertAlpha(true);

        rectangle.setDepth(1);
        rectangle.setOrigin(0, 0);
        rectangle.setMask(mask);

        circle.fillCircle(0, 0, 0.1);

        this.transition = [circle, rectangle];
    }
\end{lstlisting}

\subsection{PreloadAssets}
As mentioned before, every scene contains the method "preload()"
where the files used late on can be loaded into the respective managers/cache.
Now every asset loaded this way has a unique identifier and can be used in future scene
as long as it is not removed explicitly.
The asset can as such be loaded into the managers/cache in every scene,
so that only the actual used assets are loaded.
The advantage of this is that you can save time and storage.
But the disadvantage is that you have to be connected to the internet the whole time.
Should the connection be severed for only a short time, objects might not be displayed correctly.
With a "preload" scene in the beginning all available assets are loaded,
so that after the longer loading time the game can run fluently,
without problems and most importantly without a connection to the internet.

The attributes and path of objects in the imported json file [REFERENCE TO EXPLANATION TOP]
can be accessed by filename.["fieldname"] or filename.fieldname:

\begin{lstlisting}[style=TypeScript, caption={Example json file access}]
    ...
    for (let category of loadedJsonObjectFile['categories']) {
        console.log("URL: " + category['url']);
        console.log("Name: " + category['validElements']['name']);
        console.log("ValidElement urls: " + category['validElements']['urls']);
    }

    for (let image of loadedJsonObjectFile['images']) {
        console.log("Name: " + image.name);
        console.log("Cat1: " + image.cat1);
        ...
    }
    ...
\end{lstlisting}

The way the objects files are preloaded into the respective managers is shown below.

\begin{lstlisting}[style=TypeScript, caption={preloadAsset.ts}]
    ...
    private preload(): void {
        this.load.setPath('assets/geometrical_objects/');
        this.load.json('objects', 'geometrical_objects.json');
        ...
    }
    ...

    /**
     * Method for preloading all asset images
     */
    private preLoadImages(): void {
        // Load category and object images
        const jsonObject: any = this.cache.json.get('objects');

        for (let category of jsonObject['categories']) {
            this.load.setPath('assets/geometrical_objects/categories/');
            this.load.image(category['name'], category['url']);

            this.load.setPath('assets/geometrical_objects/images/');
            for (let property of category['validElements']) {
                for (let url of property['urls']) {
                    this.load.image(url, url);
                }
            }
        }

        for (let image of jsonObject['images']) {
            this.load.image(image['name'], image['name']);
        }
        ...
    }
    ...
\end{lstlisting}

\subsection{DropDownMenu}
In this scene the drop down menu is created.
This scene is never stops and is always on top of other scenes.

The following code in every other scene ensures this:
\begin{lstlisting}[style=TypeScript, caption={Send current scene to back}]
    ...
    create(): void {
        this.game.scene.sendToBack(this.getKey());
        ...
    }
    ...
\end{lstlisting}

As the drop down animation takes time, it was necessary to create a boolean field as a lock.
This ensures that the closing and opening animation won't interfere with each other.
The lock is freed after the competion of an event/animation.

\begin{lstlisting}[style=TypeScript, caption={Lock aquiring and freeing}]
    ...
    if (!this.lock) {
        this.lock = true;
        ...
    }
    ...
    onComplete: () => this.lock = false;
    ...
\end{lstlisting}

While the menu is down/open, the current scene has to be paused.
This is achieved by accessing the other scene by fetching the key of the only other active scene and pausing it.
Important to note is, that the last started/activated scene is at position 0 in the array of all active scenes.
\begin{lstlisting}[style=TypeScript, caption={Fetching current active scene}]
    ...
    const key_paused_scene: string = this.game.scene.getScenes(true)[0].key;
    this.game.scene.pause(key_paused_scene);
    this.key_paused_scene = key_paused_scene;
    ...
\end{lstlisting}

The same trick is used for closing all current scenes when exiting (without the dropDownMenu Scene).

\subsection{WelcomeScene}
A blinking finger is added to the screen so that the user knows that he can advance by clicking on the screen.

\subsection{LevelMenuSceneScene}
Levels with the same difficulty are distinguished by numbers from one to four.
Levels with another difficulty are distinguished by images of monsters with different level of spookiness.
[INSERT\_IMAGES\_OF\_MONSTERS]

\subsection{IntroScene}
To pause the current scene and still play the introduction animation, a separate scene is necessary.
Each time an intro has to be played, the intro scene is started anew.
The current scene is pauses itself when the intro scene is started and the name/key/identifier
of the paused scene is given to the intro scene.
That way the intro scene can resume the paused scene and then stop itself.

The respective intro material is selected via the name/key/identifier of the paused scene.

\subsection{SortingScene}
To sort the displayed objects by their respective subcategory by clicking on one of the category buttons,
random coordinates are needed dependant on the screensize and objectsize.
\begin{lstlisting}[style=TypeScript, caption={returnQuad() (sortingScene.ts)}]
    ...
    private returnQuad(quadrant: number, quadrantType: number): number[] {
        let ret: number[] = null;
        ...
        const leftOffsite: number = 100;
        const rightOffsite: number = 0;
        const topOffsite: number = 0;
        const bottomOffsite: number = 100;

        // Has entries dependant of
        const horizontal: number[] = [];

        // Has numberOfLines + 1 entries
        const vertical: number[] = [];

        horizontal.push(leftOffsite);

        vertical.push(topOffsite);

        switch (quadrantType) {
            case 3: {
                horizontal.push(leftOffsite + (this.cameras.main.width - leftOffsite - rightOffsite) / 3);
                horizontal.push(leftOffsite + (this.cameras.main.width - leftOffsite - rightOffsite) * 2 / 3);
                break;
            }
            case 4: {
                horizontal.push(leftOffsite + (this.cameras.main.width - leftOffsite - rightOffsite) / 2);
                vertical.push(topOffsite + (this.cameras.main.height - topOffsite - bottomOffsite) / 2);
                break;
            }
            case 6: {
                horizontal.push(leftOffsite + (this.cameras.main.width - leftOffsite - rightOffsite) / 3);
                horizontal.push(leftOffsite + (this.cameras.main.width - leftOffsite - rightOffsite) * 2 / 3);
                vertical.push(topOffsite + (this.cameras.main.height - topOffsite - bottomOffsite) / 2);
                break;
            }
            default: {
                break;
            }
        }

        horizontal.push(this.cameras.main.width - rightOffsite);
        vertical.push(this.cameras.main.height - bottomOffsite);

        switch (quadrantType) {
            case 3: {
                ret = [Phaser.Math.RND.between(horizontal[quadrant] + spriteSizeHalf, horizontal[quadrant + 1] - spriteSizeHalf), Phaser.Math.RND.between(vertical[0] + spriteSizeHalf + this.cameras.main.height / 8, vertical[1] - spriteSizeHalf - this.cameras.main.height / 8)];
                break;
            }
            case 4: {
                if (quadrant < 2) {
                    ret = [Phaser.Math.RND.between(horizontal[quadrant] + spriteSizeHalf, horizontal[quadrant + 1] - spriteSizeHalf), Phaser.Math.RND.between(vertical[0] + spriteSizeHalf, vertical[1] - spriteSizeHalf)];
                } else {
                    ret = [Phaser.Math.RND.between(horizontal[quadrant \% 2] + spriteSizeHalf, horizontal[(quadrant \% 2) + 1] - spriteSizeHalf), Phaser.Math.RND.between(vertical[1] + spriteSizeHalf, vertical[2] - spriteSizeHalf)];

                }
                break;
            }
            case 6: {
                if (quadrant < 3) {
                    ret = [Phaser.Math.RND.between(horizontal[quadrant] + spriteSizeHalf, horizontal[quadrant + 1] - spriteSizeHalf), Phaser.Math.RND.between(vertical[0] + spriteSizeHalf, vertical[1] - spriteSizeHalf)];
                } else {
                    ret = [Phaser.Math.RND.between(horizontal[quadrant \% 3] + spriteSizeHalf, horizontal[(quadrant \% 3) + 1] - spriteSizeHalf), Phaser.Math.RND.between(vertical[1] + spriteSizeHalf, vertical[2] - spriteSizeHalf)];
                }
                break;
            }
            default: {
                break;
            }
        }
        return ret;
    }
\end{lstlisting}

\subsection{PropertySortingScene}
To specify the difficulty level, two fields are needed:
\begin{lstlisting}[style=TypeScript, caption={Level fields (propertySortingScene.ts)}]
    ...
    private setCat: number;
    ...
    private infinite: boolean;
    ...
\end{lstlisting}

In contrast to other scenes, object must have the type Phaser.Physics.Arcade.Sprite as only arcade sprites have the
possibility of an acceleration in a direction.

As additional visual feature objects get a random spin velocity and the time a object spawns gets shorter over time.

\subsection{RestrictedSortingScene}
To check if objects in the same box have some property incommon,
the four properties of a object are taken as a list of strings and intersected with the other list of strings from other
objects in the same box.
If finally there is no empty list, the objects have some property incommon and thus this is a valid solution for one box.
Which one does not matter to us in this case.
In this way, it is possible that there are multiple solutions which were not intended but also correct.

\begin{lstlisting}[style=TypeScript, caption={equalityCheck (restrictedSortingScene.ts)}]
    ...
    private equalityCheck(gameObject: Phaser.GameObjects.Sprite, dropZone: Phaser.GameObjects.Zone): boolean {
        ...
        let mergeArray: any[] = [];
        ...
        for (let cat of this.jsonObject['categories']) {
            mergeArray = [...mergeArray, ...cat['validElements']];
        }
        mergeArray.forEach((element, index, array) => array[index] = element.name);
        ...
        [...this.objZoneMap.filter((element, index) => this.zoneObjMap[index].name === dropZone.name), gameObject].forEach(function (element) {
            mergeArray = mergeArray.filter((x) => element.getData('properties').includes(x));
        });
        ...
        return (mergeArray.length > 0);
    }
    ...
\end{lstlisting}

\subsection{GameScene}
timehandling: time added if correct

checking on update
\begin{lstlisting}[style=TypeScript, caption={update (gameScene.ts)}]
    update(time: number): void {
        ...
        if (!this.checked && this.arrayMarked.getLength() >= 3) {
            this.checked = true;
            ...
        }
        ...
        if (timedata <= 0) {
            this.checked = true;

            ...
        } else {
            timedata -= this.timedataStepsize;
            this.timefluid.setData('timeY', timedata);
            this.timefluid.setScale(this.timefluid.getData('timeX'), timedata);
        }
    }
\end{lstlisting}

points counting with epsilon
\begin{lstlisting}[style=TypeScript, caption={updateProgressbar (gameScene.ts)}]
    ...
    if (this.points >= this.gamefluid.getData('gameMax') - Phaser.Math.EPSILON) {
        ...
    }
\end{lstlisting}

algorithm for checking with option of coloring the helpers menu
\begin{lstlisting}[style=TypeScript, caption={checkEquality (gameScene.ts)}]
    ...
    private checkEquality(sprite1: Phaser.GameObjects.GameObject, sprite2: Phaser.GameObjects.GameObject, sprite3: Phaser.GameObjects.GameObject, inGame: boolean): boolean {
        if (sprite1 instanceof Phaser.GameObjects.Sprite &&
            sprite2 instanceof Phaser.GameObjects.Sprite &&
            sprite3 instanceof Phaser.GameObjects.Sprite
        ) {
            // Return value
            let replaceObjects: boolean = true;

            for (let categoryIndicator of this.arrayCategory.getChildren()) {

                // Make sure your objects are sprites
                if (categoryIndicator instanceof Phaser.GameObjects.Sprite) {

                    // Clear tint
                    categoryIndicator.clearTint();

                    if (
                        sprite1.getData(categoryIndicator.name) === sprite2.getData(categoryIndicator.name) &&
                        sprite2.getData(categoryIndicator.name) === sprite3.getData(categoryIndicator.name) &&
                        sprite1.getData(categoryIndicator.name) === sprite3.getData(categoryIndicator.name)
                    ) {
                        if (inGame) {
                            categoryIndicator.setTintFill(0x00dd00);
                        }
                    } else if (
                        !(sprite1.getData(categoryIndicator.name) === sprite2.getData(categoryIndicator.name)) &&
                        !(sprite2.getData(categoryIndicator.name) === sprite3.getData(categoryIndicator.name)) &&
                        !(sprite1.getData(categoryIndicator.name) === sprite3.getData(categoryIndicator.name))
                    ) {
                        if (inGame) {
                            categoryIndicator.setTintFill(0x00dd00);
                        }
                    } else {
                        if (replaceObjects) {
                            replaceObjects = false;
                        }
                        if (inGame) {
                            // Mark category as red
                            categoryIndicator.setTintFill(0xdd0000);
                        }
                    }
                }
            }
            return replaceObjects;
        }
    }
\end{lstlisting}

time added if correct
\begin{lstlisting}[style=TypeScript, caption={updateProgressbar (gameScene.ts)}]
    ...
    let timedata: number = this.timefluid.getData('timeY');
    timedata += this.timedataStepsize * 5000;
    if (timedata > this.timefluid.getData('timeYMax')) {
        timedata = this.timefluid.getData('timeYMax');
    }
    ...
\end{lstlisting}

replace all if not a valid solution
\begin{lstlisting}[style=TypeScript, caption={INSERT (gameScene.ts)}]
    ...
    private rebuildDisplayedObjects(): void {
        ...
        for (let card of this.arrayDisplayed.getChildren()) {
            if (card instanceof Phaser.GameObjects.Sprite) {
                card.setVisible(false);
                this.arrayStack.add(card);
            }
        }

        this.arrayDisplayed.clear(false, false);

        this.initObjects();
    }
    ...
\end{lstlisting}

\subsection{ScoreScene}


\section{Final look of the learning environment}


\section{Checklist}

- overview of your solution. Give a good explanation of its rationale,
concepts and mechanisms. If your solution relies on a
theorem or some other undocumented concept, make sure
that you explain them before you carry on to the detailed
description.

The main part of this section is the thorough descrip-
tion of the solution and its functionality.
The description should not contain arguments on correctness or design de-
cision debates; simply, describe the mechanisms of your
solution and avoid explanations of the 'why so' type.
Dedicate a separate paragraph or two on the latter, if
you deem necessary.

Disassemble your solution to its functional components
and explain them separately. For example, if you describe
a distributed algorithm, explain the protocol-specific part
(message format, etc.) separately from the semantics and
decision-making part of the algorithm.
It is both important and useful to provide figures
demonstrating the functionality of your solution. Make
the figures look similar to the system model figure, if ap-
plicable, and exploit the similarities and differences to
point out important aspects of your solution.

Analysis can be of two types: qualitative and quantitative.
The former means to show some properties (qualities)
of your solution, while the latter means to show some
performance aspects of your solution.
Qualitative analysis is usually proof of correctness,
however it could be proof that the solution possesses some
desired property. For algorithms or protocols, a proof of
correctness is always welcome.
Quantitative analysis is mostly performance analysis.
It is important to explain what performance metric you
use and why you have selected the specific metric. Choos-
ing a metric that has been widely used will make the
comparison to other solutions easier.
