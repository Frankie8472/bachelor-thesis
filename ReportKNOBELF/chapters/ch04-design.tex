% !TEX root = ../thesis.tex

\chapter{Design of the Learning Environment}
\label{chap:design}

In this section all implementation tools and approaches are explained.
First our used framework will be explained, then how our different scenes and objects are generated and
at last how these two are combined to our final solution.

\section{Phaser 3}
%https://labs.phaser.io/
%https://phaser.io/
%https://photonstorm.github.io/phaser3-docs/

\subsection{Scenes}
\subsection{Managers}
\section{Object generation}
Our objects can have up to four properties with at maximum one from each of the following categories:
\begin{itemize}
    \item Geometrical shape (square, triangle, circle, ellipse, rhombus, octagon)
    \item Color (yellow, orange, red, purple, green, blue)
    \item Holes or dots (one, two, three, four, five, six)
    \item Filling (filled, striped, dotted)
\end{itemize}

We need all possible objects with one, three and four properties.

With a python script [EXAMPLE] scalable vector graphic (SVG) files are generated [EXAMPLE].
After that they are converted to portable network graphic (PNG) files with the GNU image manipulation program (GIMP),
so that they can be imported into Phaser.

\section{Object storage}
Our objects are images with different properties.
These properties cannot be saved in the images itself.
for that reason the image path with the respective properties are stored in a easily accessible
"JavaScript Object Notation" (JSON) file.

\begin{lstlisting}[style=TypeScript, caption=geometrical_objects.json]
{
  "categories": [
    {
      "name": "cat1",
      "url": "color.png",
      "validElements": [
        {
          "name": "purple",
          "urls": [
            "purple1.png",
            "purple2.png",
            "purple3.png",
            "purple4.png",
            "purple5.png",
            "purple6.png"
          ]
        },
        ...
      ]
    },
    ...
  ],
  "images": [
    {
      "name": "purplesquareonefull.png",
      "cat1": "purple",
      "cat2": "square",
      "cat3": "one",
      "cat4": "full"
    },
    ...
  ]
}
\end{lstlisting}

For the correct way to access the fields please go to [INSERTCHAPTER].

\section{Introduction Animation Generation}
To produce animated instruction for the task later on,
the screen is recorded with OBS Studio while someone (here me) is playing the game.
Parts of the final video are then taken for the respective scenes and converted into single pictures.
These single pictures are saved in one picture (called spreadsheet [EXAMPLE]).
The phaser framework animates those spreadsheets.

\section{Concept of the Learning Environment}
Through the boundary conditions and requirements of the learning environment,
we split our environment into multiple parts or here called scenes.

\subsection{Drop Down Menu}
Throughout the whole experience, the user can open a menu with a button.
This button is always visible.
Once the menu is open, the user may close the menu and return to the current scene,
exit the current scene and return to the level menu and go into fullscreen and back.
The current scene is paused while the menu is open as it can be distracting for the user,
if suddenly something pops up and covers parts of the visible and running scene.

\subsection{Welcome Screen}
The welcome screen is the starting point of the user experience.
Through this screen the user will be greeted by showing the name of the game.
Through a click he shall commence to the level menu.

\subsection{Level Menu}
In the level menu, the user is able to choose between different levels and games.
He can also access the object summary and track his progress/score.
The progress of each individual level is shown on the respective buttons.

\subsection{Object summary}
The Object summary allows the user to get a feeling for all the different properties an object can have.
For that reason the number of objects per category is restricted to five, as there are over 1000 different objects.
Objects are draggable and sortable by each category with a click on a respective button.

\subsection{Sorting with one category}
Here the user has to sort the static objects with one category by the given category.
As the user should be able to experience all categories, they are split into different levels.
Each level represents a category.
For motivation, the user can track his progress.
The Progress is defined by objects sorted the right and the wrong way.

The amount of objects to sort, as well as the amount of properties of the category
is randomly selected each time you start the game.

\subsection{Sorting with one category under difficult conditions}
Here the user has to sort falling objects with one category by the given category.
As the user should be able to experience all categories, they are split into different level.
Each level represents a category.
For motivation, the user can track his progress.
The progress is defined by objects missed, sorted the right and the wrong way.
To make the task harder, dummy objects are added.
Those objects look similar to the original ones but with a succinct characteristic.
There are no negative points for missing such an object but negative points for sorting them in any way.

The amount of falling objects to sort, as well as the amount of properties of the category
is randomly selected each time you start the game.

\subsection{Sorting with restricted space}
In this scene the user has to sort a given number of objects with all properties shown into boxes with limited space.
The objects in one box must have at least one property incommon and
can be put into the box and taken out an infinite amount of times.

To make the game more difficult, this level is split into two.
The first level has boxes with the size 6, 4, 2 and the second one boxes with the size 6, 5, 4.
%E.g. For the category colors: In the end, box 1 contains 6 objects that are blue, box 2 contains 4 objects
%that are yellow and box 3 contains 2 obejcts that are red. In total there are 12 objects.
%The objects are random generated, so that at least one category fits.
%The possibility of cross category matching is considered and will also count.
%E.g. In the end, box 1 containt 6 objects that are blue, box 2 contains 4 objects that are squares
%and box 3 containts 2 objects that have 3 dots/holes.

\subsection{Object pairing - easy version}
In this game, twelve objects with three categories are shown.
the user has to select three objects which have to fulfil the following.
For each category (color, shape and number of holes/dots) one of the following conditions has to hold:
\begin{itemize}
    \item They must be the same (blue, blue, blue)
    \item They must be completely different (square, triangle, circle)
\end{itemize}
[EXAMPLE]

If the user needs help, there is a helper bar which can be accessed by a button with a question mark on it.
The helper bar shows which categories fulfil the conditions and which do not
by coloring the category symbols on the bar in green or red.

The game is time limited. The remaining time is shown by a bar.
If you select three onjects which fulfil the conditions, more time will be added.
After a set amount of correct selected objects, the game will end.

If there are no three objects that fulfil the conditions, the playfield will be generated anew.

\subsection{Object pairing - normal version}
In this game, twelve objects with four categories are shown.
the user has to select three objects which have to fulfil the following.
For each category (color, filling, shape and number of holes/dots) one of the following conditions has to hold:
\begin{itemize}
    \item They must be the same (blue, blue, blue)
    \item They must be completely different (square, triangle, circle)
\end{itemize}
[EXAMPLE]

If the user needs help, there is a helper bar which can be accessed by a button with a question mark on it.
The helper bar shows which categories fulfil the conditions and which do not
by coloring the category symbols on the bar in green or red.

The game is time limited. The remaining time is shown by a bar.
If you select three onjects which fulfil the conditions, more time will be added.
After a set amount of correct selected objects, the game will end.

If there are no three objects that fulfil the conditions, the playfield will be generated anew.

\subsection{Score Screen}
After a task has been completed, there is going to be a score.
This score is represented here with a displayed number of stars.
The minimum of starts is zero and the maximum is three.
If the user is unhappy with his results, he can replay the game by clicking on the replay button.

\subsection{Introduction}
Before each game starts, a sample animation of the task beforehand is being shown.
The current scene is paused in the meantime, so that the user has enough time to find out what he has to do.

\section{Code structure of the learning environment}
Our learning environment consists of different scenes each one inheriting the base scene.
The following subsections won't contain the whole code as some parts are trivial to understand.
Instead a summary of the scenes purpose and crucial parts are shown and explained.

[IMAGE_OF_STATE_DIAGRAM]

\subsection{BaseScene}
This scene contains methods and fields which are neccessary in multiple scenes
(e.g. the scene transition, indentifier of the scene, ...).

The transition is a mask in the form of a circle layed over a black rectangle.
Masks have to be applied to every object they have to mask.
So a simple solution was to lay a black rectangle over the whole scene and mask it.
The animated transition is created by increasing or decreasing the radius of the circle
mask according to the wanted animation (IN/OUT).

\begin{lstlisting}[style=TypeScript, caption=BaseScene.ts]
    /**
     * Method for initializing the shape, position and properties of the graphical scene transition
     */
    private transitionInit(): void {
        // Shape of the graphical transition
        const circle: Phaser.GameObjects.Graphics = this.add.graphics();

        // Shape of the screen
        const rectangle: Phaser.GameObjects.Rectangle = this.add.rectangle(0, 0, this.cameras.main.width, this.cameras.main.height, 0x000000);

        // Define circle as the mask
        const mask: Phaser.Display.Masks.GeometryMask = circle.createGeometryMask();

        circle.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);
        circle.fillCircle(0, 0, 0.1);
        circle.setDepth(0);

        mask.setInvertAlpha(true);

        rectangle.setDepth(1);
        rectangle.setOrigin(0, 0);
        rectangle.setMask(mask);

        circle.fillCircle(0, 0, 0.1);

        this.transition = [circle, rectangle];
    }
\end{lstlisting}

\subsection{PreloadAssets}
As mentioned before, every scene contains the method "preload()"
where the files used late on can be loaded into the respective managers/cache.
Now every asset loaded this way has a unique identifier and can be used in future scene
as long as it is not removed explicitly.
The asset can as such be loaded into the managers/cache in every scene,
so that only the actual used assets are loaded.
The advantage of this is that you can save time and storage.
But the disadvantage is that you have to be connected to the internet the whole time.
Should the connection be severed for only a short time, objects might not be displayed correctly.
With a "preload" scene in the beginning all available assets are loaded,
so that after the longer loading time the game can run fluently,
without problems and most importantly without a connection to the internet.

The attributes and path of objects in the imported json file [REFERENCE TO EXPLANATION TOP]
can be accessed by filename.["fieldname"] or filename.fieldname:

\begin{lstlisting}[style=TypeScript, caption=Example json file access]
    ...
    for (let category of loadedJsonObjectFile['categories']) {
        console.log("URL: " + category['url']);
        console.log("Name: " + category['validElements']['name']);
        console.log("ValidElement urls: " + category['validElements']['urls']);
    }

    for (let image of loadedJsonObjectFile['images']) {
        console.log("Name: " + image.name);
        console.log("Cat1: " + image.cat1);
        ...
    }
    ...

\end{lstlisting}

The way the objects files are preloaded into the respective managers is shown below.

\begin{lstlisting}[style=TypeScript, caption=preloadAsset.ts]
    ...
    preload(): void {
        this.load.setPath('assets/geometrical_objects/');
        this.load.json('objects', 'geometrical_objects.json');
        ...
    }
    ...

    /**
     * Method for preloading all asset images
     */
    private preLoadImages(): void {
        // Load category and object images
        const jsonObject: any = this.cache.json.get('objects');

        for (let category of jsonObject['categories']) {
            this.load.setPath('assets/geometrical_objects/categories/');
            this.load.image(category['name'], category['url']);

            this.load.setPath('assets/geometrical_objects/images/');
            for (let property of category['validElements']) {
                for (let url of property['urls']) {
                    this.load.image(url, url);
                }
            }
        }

        for (let image of jsonObject['images']) {
            this.load.image(image['name'], image['name']);
        }
        ...
    }
    ...
\end{lstlisting}

\subsection{DropDownMenu}
In this scene the drop down menu is created.
This scene is never stops and is always on top of other scenes.

The following code in every other scene ensures this:
\begin{lstlisting}[style=TypeScript, caption=Send current scene to back]
    ...
    create(): void {
        this.game.scene.sendToBack(this.getKey());
        ...
    }
    ...
\end{lstlisting}

As the drop down animation takes time, it was necessary to create a boolean field as a lock.
This ensures that the closing and opening animation won't interfere with each other.
The lock is freed after the competion of an event/animation.

\begin{lstlisting}[style=TypeScript, caption=Lock aquiring and freeing]
    ...
    if (!this.lock) {
        this.lock = true;
        ...
    }
    ...
    onComplete: () => this.lock = false;
    ...
\end{lstlisting}

While the menu is down/open, the current scene has to be paused.
This is achieved by accessing the other scene by fetching the key of the only other active scene and pausing it.
Important to note is, that the last started/activated scene is at position 0 in the array of all active scenes.
\begin{lstlisting}[style=TypeScript, caption=Lock aquiring and freeing]
    ...

    ...
\end{lstlisting}


\subsection{WelcomeScene}
\subsection{LevelMenuSceneScene}
\subsection{IntroScene}
\subsection{SortingScene}
\subsection{PropertySortingScene}
\subsection{RestrictedSortingScene}
\subsection{GameScene}
\subsection{ScoreScene}


\section{Final look of the learning environment}


\section{Checklist}

- overview of your solution. Give a good explanation of its rationale,
concepts and mechanisms. If your solution relies on a
theorem or some other undocumented concept, make sure
that you explain them before you carry on to the detailed
description.

The main part of this section is the thorough descrip-
tion of the solution and its functionality.
The description should not contain arguments on correctness or design de-
cision debates; simply, describe the mechanisms of your
solution and avoid explanations of the 'why so' type.
Dedicate a separate paragraph or two on the latter, if
you deem necessary.

Disassemble your solution to its functional components
and explain them separately. For example, if you describe
a distributed algorithm, explain the protocol-specific part
(message format, etc.) separately from the semantics and
decision-making part of the algorithm.
It is both important and useful to provide figures
demonstrating the functionality of your solution. Make
the figures look similar to the system model figure, if ap-
plicable, and exploit the similarities and differences to
point out important aspects of your solution.

Analysis can be of two types: qualitative and quantitative.
The former means to show some properties (qualities)
of your solution, while the latter means to show some
performance aspects of your solution.
Qualitative analysis is usually proof of correctness,
however it could be proof that the solution possesses some
desired property. For algorithms or protocols, a proof of
correctness is always welcome.
Quantitative analysis is mostly performance analysis.
It is important to explain what performance metric you
use and why you have selected the specific metric. Choos-
ing a metric that has been widely used will make the
comparison to other solutions easier.
